import {InsightDatasetKind, InsightError} from "./IInsightFacade";
import JSZip from "jszip";
import Section, {JsonSection} from "./Section";
import Room, {GeoResponse} from "./Room";
import * as parse5 from "parse5";
import Dataset from "./Dataset";
import {BuildingHtmProcessor} from "./BuildingHtmProcessor";

export default class DatasetProcessor {
	private readonly jsZip: JSZip;
	private readonly id: string;
	private datasets: Map<string, Dataset>;

	constructor(jsZip: JSZip, id: string, datasets: Map<string, Dataset>) {
		this.jsZip = jsZip;
		this.id = id;
		this.datasets = datasets;
	}

	public async process(kind: InsightDatasetKind): Promise<any[]> {
		let parsedData: any[] = [];

		if (kind === InsightDatasetKind.Sections) {
			// console.log("(4) processing section kind");
			parsedData = await this.processSectionZip(this.jsZip, this.id);
		} else if (kind === InsightDatasetKind.Rooms) {
			// console.log("(4) processing room kind");
			parsedData = await this.processRoomZip(this.jsZip, this.id);            //
		}

		// console.log("(13) parsed data returned to process:", parsedData);
		return parsedData;
	}

	// this block of code is generated by ChatGPT
	private async processSectionZip(jsZip: JSZip, id: string): Promise<any[]> {
		const parsedData: any[] = [];
		let hasValidCourse = false;

		await Promise.all(
			Object.values(jsZip.files).map(async (zipEntry) => {
				try {
					if (zipEntry.name.startsWith("courses/") && zipEntry.name !== "courses/") {
						const fileContent = await zipEntry.async("string");
						const jsonData = JSON.parse(fileContent);

						let sectionList = (this.processSections(jsonData.result));

						if (sectionList.length > 0) {
							hasValidCourse = true;
							parsedData.push(jsonData);
							this.datasets.get(id)?.addDatasetData(sectionList, InsightDatasetKind.Sections);
						}
					}
				} catch (error) {
					console.error("Error parsing JSON for file:", zipEntry.name);
					console.error("Error details:", error);
				}
			})
		);

		if (!hasValidCourse) {
			throw new InsightError("Error adding the dataset: no valid courses");
		}

		return parsedData;
	}

	// Process each valid section in the "result" key
	private processSections(results: JsonSection[]): Section[] {
		const sectionList: Section[] = [];
		results.forEach((result) => {
			const section = new Section(result as JsonSection, "JsonSection");
			sectionList.push(section);
		});
		return sectionList;
	}

	// ChatGPT: improved parallelism
	private async processRoomZip(jsZip: JSZip, id: string): Promise<any> {
		const indexHtml = jsZip.file("index.htm");
		if (!indexHtml) {
			throw new InsightError("Error processing room zip: invalid index.htm");
		}

		const indexContent = await (indexHtml as JSZip.JSZipObject).async("string");
		const indexParsed = parse5.parse(indexContent);
		const targetIndexTable = this.findTargetTable(indexParsed);

		const buildingFullnames = this.extractBuildingFullnamesFromIndexTable(targetIndexTable);
		const buildingShortnames = this.extractBuildingShortnamesFromIndexTable(targetIndexTable);
		const buildingAddresses = this.extractBuildingAddressFromIndexTable(targetIndexTable);
		const buildingLinks = this.extractBuildingLinksFromIndex(targetIndexTable);

		const buildingPromises = buildingLinks.map(async (roomLink) => {
			return this.processBuildingFile(jsZip, roomLink);
		});
		const buildingResults = await Promise.all(buildingPromises);

		if (buildingResults.length > 0) {
			buildingResults.forEach((roomList) => {
				roomList.forEach((room) => {
					room.setBuildingInformation(buildingFullnames[0], buildingShortnames[0], buildingAddresses[0]);
				});
				buildingFullnames.shift();
				buildingShortnames.shift();
				buildingAddresses.shift();
			});

			const setLonAndLatPromises = buildingResults.map(async (buildingRooms) => {
				if (buildingRooms.length > 0) {
					const geoResponse: GeoResponse = await buildingRooms[0].getBuildingLonAndLat();
					const setLatLonPromises = buildingRooms.map((room) => room.setLatLon(geoResponse));
					await Promise.all(setLatLonPromises);
				}
			});
			await Promise.all(setLonAndLatPromises);
		}

		const roomsList = buildingResults.reduce((acc, val) => acc.concat(val), []);
		this.datasets.get(id)?.addDatasetData(roomsList, InsightDatasetKind.Rooms);

		return roomsList;
	}

	private extractBuildingFullnamesFromIndexTable(indexTable: any): string[] {
		let buildingFullnames: string[] = [];

		// ChatGPT: change processing nodes to recursive
		function processNode(node: any) {
			if (node.nodeName === "a" && node.attrs && node.attrs[0].name && node.attrs[0].name === "href"
				&& node.attrs[0].value) {
				const buildingHref = node.attrs[0].value;
				if (buildingHref.endsWith(".htm")) {
					if (node.childNodes) {
						for (const childNode of node.childNodes) {
							const buildingFullname = childNode.value.trim();
							if (buildingFullname !== "More info") {
								if (buildingFullname.length !== 0) {
									buildingFullnames.push(buildingFullname);
								} else {
									buildingFullname.push("");
								}
							}
						}
					}
				}
			} else if (node.childNodes) {
				for (const childNode of node.childNodes) {
					processNode(childNode);
				}
			}
		}

		if (indexTable && indexTable.childNodes) {
			const childNodes = Array.from(indexTable.childNodes);
			for (const childNode of childNodes) {
				const node: any = childNode as any;
				if (node.tagName === "tr") {
					processNode(node);
				}
			}
		}

		return buildingFullnames;
	}

	private extractBuildingShortnamesFromIndexTable(indexTable: any): string[] {
		let buildingCodes: string[] = [];
		function processNode(node: any) {
			if (node.attrs && node.attrs[0] && node.attrs[0].value === "views-field views-field-field-building-code") {
				if (node.childNodes && node.childNodes[0] && node.childNodes[0].value) {
					buildingCodes.push(node.childNodes[0].value.trim());
				} else {
					buildingCodes.push("");
				}
			} else if (node.childNodes) {
				for (const childNode of node.childNodes) {
					processNode(childNode);
				}
			}
		}

		if (indexTable && indexTable.childNodes) {
			const childNodes = Array.from(indexTable.childNodes);
			for (const childNode of childNodes) {
				const node: any = childNode as any;
				if (node.tagName === "tr") {
					processNode(node);
				}
			}
		}

		return buildingCodes;
	}

	private extractBuildingAddressFromIndexTable(indexTable: any): string[] {
		let buildingAddresses: string[] = [];
		function processNode(node: any) {
			if (node.attrs && node.attrs[0] && node.attrs[0].value &&
				node.attrs[0].value === "views-field views-field-field-building-address") {
				if (node.childNodes && node.childNodes[0]) {
					buildingAddresses.push(node.childNodes[0].value.trim());
				} else {
					buildingAddresses.push("");
				}
			} else if (node.childNodes) {
				for (const childNode of node.childNodes) {
					processNode(childNode);
				}
			}
		}

		const childNodes = Array.from(indexTable.childNodes);
		for (const childNode of childNodes) {
			const node: any = childNode as any;
			if (node.tagName === "tr") {
				processNode(node);
			}
		}

		return buildingAddresses;
	}

	private extractBuildingLinksFromIndex(indexTable: any): string[] {
		let buildingsHrefs = new Set<string>();

		// ChatGPT: change processing nodes to recursive
		function processNode(node: any) {
			if (node.nodeName === "a" && node.attrs){
				for (const attr of node.attrs) {
					if (attr.name === "href") {
						const buildingHref = attr.value;
						if (buildingHref.endsWith(".htm")) {
							buildingsHrefs.add(buildingHref.substring(2));	// get rid of the front ./
						}
					}
				}
			} else if (node.childNodes) {
				for (const childNode of node.childNodes) {
					processNode(childNode);
				}
			}
		}

		const childNodes = Array.from(indexTable.childNodes);
		for (const childNode of childNodes) {
			const node: any = childNode as any;
			if (node.tagName === "tr") {
				processNode(node);
			}
		}
		return Array.from(buildingsHrefs);
	}

	private async processBuildingFile(jsZip: JSZip, buildingLink: string): Promise<Room[]> {
		const matchingFiles = Object.keys(jsZip.files).filter((fileKey) => fileKey.endsWith(buildingLink));
		const buildingFile = jsZip.file(matchingFiles[0]);		// there should only be 1 matching file
		const buildingContent = await buildingFile?.async("string");
		const buildingHtmProcessor = new BuildingHtmProcessor();
		if (buildingContent) {
			const buildingParsed = parse5.parse(buildingContent);
			buildingHtmProcessor.extractRoomsFromBuilding(buildingParsed);
			return buildingHtmProcessor.parseRooms();
		} else {
			return [];
		}
	}

	private findTargetTable(node: any): any {
		if (node.tagName === "table" && node.attrs.find((attr: any) => attr.name === "class" &&
			attr.value === "views-table cols-5 table")) {
			if (node.childNodes) {
				const tbodyNode = node.childNodes.find((child: any) => child.tagName === "tbody");
				if (tbodyNode) {
					return tbodyNode;
				}
			}
		} else if (node.childNodes) {
			for (const child of node.childNodes) {
				const result = this.findTargetTable(child);
				if (result) {
					return result;
				}
			}
		}
		return null;
	}

}
